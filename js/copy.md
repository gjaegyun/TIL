# copy

## 얕은복사
## 깊은복사

``` js
    const arr = ["김재균", "잘생겼다"];
    const real = arr;

    const [...notReal1] = arr;
    const notReal2 = [...arr];
    
    arr[1] = "잘못생겼다";

    console.log(arr); // ["김재균", "잘못생겼다"];
    console.log(real); // ["김재균", "잘못생겼다"];
    console.log(notReal1);  // ["김재균", "잘생겼다"];
    console.log(notReal2); // ["김재균", "잘생겼다"];
```

- 얕은복사 real은 arr을 참조하기 때문에 arr[1]의 값이 변경됩니다. (사실 real은 real의 값을 메모리상으로 가리키고 있음);

- 깊은복사 notReal1, 2같은 경우는 참조가 아닌 값을 독립적인 메모리 공간에 할당하기 때문에 메모리 상으로는 같은 값이긴 하지만 다른곳을 가리키고 있습니다.

- 그래서 얕은복사 real은 메모리상으로 같은곳을 가리키고 있어, 변경이 되고, 깊은복사 notReal1, 2는 메모리상으로 다른 공간에 할당되있기 때문에 변경되지 않았습니다.

- **단 원시값은 주소값이 아닌 데이터 자체이기 때문에 해당 X**

### 둘은 서로 왜쓰이나???

- 얕은복사는 왜쓰이나 생각을 많이 했었는데 사실 간단했다.

- 바로 돈 때문임(메모리 주소를 새로 할당 X -> 메모리 공간 많이 필요 X)

- 깊은 복사 -> 메모리 주소에 새로 할당 -> 메모리 공간 많아야 함